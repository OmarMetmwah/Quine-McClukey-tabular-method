###Tabular Method in decimal#####Group No.11##Members:	#(Omar Mohamed ElSayed Metmwah-19016082)	#(Ibrahim Tarek Ibrahem AbdElaal-19015167 )	#(Mohamed Ibrahim Mohamed WahbAllah-19016267 )	#(Marwan Mahmoud Ibrahim Mohamed- 19016621)	#(Ahmed Rabea Salem Ali- 19015229)	import mathimport sysimport itertools##Defining Fuctions #Hamming Distance between two numbers x and ydef hammingDistance(x, y):    ans = 0    for i in range(31, -1, -1):        b1 = x >> i & 1        b2 = y >> i & 1        ans += not (b1 == b2)    return ans#The Number of ones in Binarydef noOfOnes(n):        binary = bin(n)[2:]        result = binary.count('1')        return result#Turn the groups to group of two coordinates (ex [[1,2],[5,9] => [[[1,0],[2,0]],[[5,0],[9,0]]]) So that each number is ready to be combing in formdef listing(group):    for i in range(len(group)):        for j in range(len(group[i])):            group[i][j]= [group[i][j]]    return group#Grouping Numbers According To Number Of Onesdef groupingHamming(variablesNum,mintermsList):    groups = [[] for i in range(variablesNum + 1)]    for i in range(len(mintermsList)):        #Check whether any of the inputs is out of range        if len(bin(mintermsList[i])[2:]) > variablesNum:            print('\nError: Wrong number of variables\n')            sys.exit(0)        index = noOfOnes(mintermsList[i])        #Grouping by number of ones separately        groups[index].append(mintermsList[i])    return groups#Compine pairs of different groups which have different number of ones and have hamming distance = 1def firstcombine(group, untaken):    #Removing Empty Groups that have no terms in it    group = [x for x in group if x != []]	#Define The length of output group    length = len(group) - 1    check_list = []    next_group = [[] for x in range(length)]    #Passing through the groups    for i in range(length):        #The first group        for n1 in group[i]:            # The second group            for n2 in group[i + 1]:                #Checking whether the hamming distance equal 1                checker = (hammingDistance(n1[0],n2[0]) == 1)                if checker:                    #Add the numbers used to the check list to know that we have combined them                    check_list.append(n1)                    check_list.append(n2)                    #Combine two numbers and add their difference to the list                    new_num = n1.copy()                    new_num.append(abs(n1[0]-n2[0]))                    next_group[i].append(new_num)    #Put the elements that had not been paired in untaken list    for i in group:        for j in i:            if j not in check_list:                untaken.append(j)    return next_group, untaken#Combining the rest of groups that result from the first stage of combinationdef restcombine(group, untaken):    length = len(group) - 1    check_list = []    next_group = [[] for x in range(length)]    #Passing through the groups    for i in range(length):        #The first group        for n1 in group[i]:            # The second group            for n2 in group[i + 1]:                #Checking whether the hamming distance equal 1                checker = (hammingDistance(n1[0],n2[0]) == 1) and n1[1:] == n2[1:]                if checker:                    #Add the numbers used to the check list                    check_list.append(n1)                    check_list.append(n2)                    #Combine two numbers and add their difference to the list                    new_num = n1.copy()                    new_num.append(abs(n1[0]-n2[0]))                    next_group[i].append(new_num)    #Remove repeated    for i in range(len(next_group)):        for j in range(len(next_group[i])):            next_group[i][j][1:] = sorted(next_group[i][j][1:])    for i in range(len(next_group)):        for j in range(len(next_group[i])):            for k in range(len(next_group[i])):                if next_group[i][j] == next_group[i][k] and k!=j :                    next_group[i][k]= []    for i in range(len(next_group)):        for j in range(len(next_group[i])):            next_group[i] = [x for x in next_group[i] if x != []]    #Put the elements that had not been paired in untaken list    for i in group:        for j in i:            if j not in check_list:                untaken.append(j)    return next_group, untaken#remove redundant in one dimention listdef remove_redundant_list(list):    new_list = []    for i in list:        if i not in new_list:            new_list.append(i)    return new_list    #Make sure that the chart is emptydef check_all_zero(chart):    for i in chart:        for j in i:            if j != 0:                return False    return True    #remove redundant lists in 2 dimention listdef remove_redundant(group):    new_group = []    for j in group:        new=[]        for i in j:            if i not in new:                new.append(i)        new_group.append(new)    return new_group#Multiply two terms to get possible combinations that covers the function (for ex. (p1 + p2)(p1+p4+p5) ) multiply and returns the productdef multiply(list1, list2):    list_result = []    #if both of them is empty    if len(list1) == 0 and len(list2)== 0:        return list_result    #if one is empty    elif len(list1)==0:        return list2    #if another is empty    elif len(list2)==0:        return list1    #both not empty    else:        for i in list1:            for j in list2:                if i == j:                    list_result.append(i)                else:                    list_result.append(list(set(i+j)))        #sort and remove redundant lists        list_result.sort()        return list(list_result for list_result,_ in itertools.groupby(list_result))#Petrick Methoddef petrick_method(chart,noOfVariables):    P = []    for col in range(pow(2, noOfVariables)):        p =[]        for row in range(len(chart)):            if chart[row][col] == 1:                p.append([row])        P.append(p)    for l in range(len(P)-1):        P[l+1] = multiply(P[l],P[l+1])    P = sorted(P[len(P)-1],key=len)    final = []    #find the terms with min length = this is the one with lowest cost    min=len(P[0])    for i in P:        if len(i) == min:            final.append(i)        else:            break    return final#find essential prime implicants ( col num of ones = 1)def find_prime(chart,noOfVariables):    prime = []    for col in range(pow(2, noOfVariables)):        count = 0        pos = 0        for row in range(len(chart)):            if chart[row][col] == 1:                count += 1                pos = row        if count == 1:            prime.append(pos)    return primedef minimumCost(chart, noOfVariables,all):    P_final = []    #essential_prime = list with terms with only one 1 (Essential Prime Implicants)    essential_prime = find_prime(chart,noOfVariables)    essential_prime = remove_redundant_list(essential_prime)    #print out the essential primes    if len(essential_prime)>0:         print("\n☛The number of Essential Prime Implicants : "+ str(len(essential_prime)))         print("######################")         print("\n☛Essential Prime Implicants :\n")         for i in essential_prime:                print(numToLetter(all[i],noOfVariables))         print("##################### ")     	    #modifiy the chart to exclude the covered terms    for i in essential_prime:        for col in range(pow(2, noOfVariables)):            if chart[i][col] == 1:                for row in range(len(chart)):                    chart[row][col] = 0    #Print Reduced chart    remove_redundant_list(chart)    print("\n☛Reduced chart:")    print(("  "*5),end='')    for i in range(pow(2,noOfVariables)):    	if i <10:    		print(str(i)+"  ",end='')    	else:    		print(str(i)+" ",end='')    print("\n")    for i in range(len(chart)):    				if chart[i] == [0 for x in range(pow(2,noOfVariables))]:    					continue    				s = numToLetter(all[i],noOfVariables)    				print(s,end='')    				intialSpace =(2*noOfVariables)-len(s)+1    				print((" "*intialSpace),end='')    				for j in chart[i]:    					if j==0:    						print("   ",end='')    					else:    						print(" x ",end='')    				print("\n")    print("##################### ")    #if all zero, no need for petrick method    if check_all_zero(chart) == True:        P_final = [essential_prime]    else:        P = petrick_method(chart,noOfVariables)        P_cost = []        for x in P:               for i in x:               	cost = cal_efficient(all[i],noOfVariables)               P_cost.append(cost)        for i in range(len(P_cost)):             if P_cost[i] == min(P_cost):                P_final.append(P[i])        #append prime implicants to the solution of Petrick's method    for i in P_final:            for j in essential_prime:                if j not in i:                    i.append(j)    return P_final#calculate the number of literalsdef cal_efficient(n, noOfVariables):    cost = noOfVariables + 1 - len(n)    return cost#Turn terms from number into letters of expressiondef numToLetter(num,noOfVariables):	char= [chr(ord('A')+n) for n in range(noOfVariables)]	charValue=[pow(2,noOfVariables-n-1) for n in range(noOfVariables)]	total = num[0]	term = ""	sum = 0	for i in range(noOfVariables):									if charValue[i] not in num[1:]:										if sum+ charValue[i] <= total :											term = term + char[i]											sum = sum + charValue[i]										else:											term = term + char[i] + "\'"	return(term)def main():    #Get the number  of variables from user    noOfVariables = int(input("Enter number of variables: "))    # Get the  number of minterms from user    noOfMinterms = int( input("Enter number of minterms: "))    #Get the minterms from user    minterms = input("Enter the minterms !Any Order&No Repetition! (in the form : 1 2 3 5 12 13 ): ")    #Separate The inputs in list    minterms = minterms.split()    #Make Unique list of minterms with no repetition    minterms_unique = []    for x in minterms:        if x not in minterms_unique:            minterms_unique.append(x)    minterms = minterms_unique.copy()    #Check whether the inputs are correct    if noOfMinterms != len(minterms):        print("Wrong number of minterms")        sys.exit(0)    #Turn The list of Terms into numbers (int)    minterms = list( map(int, minterms) )    #Grouping Minterms According To Number Of Ones    print("\n☛<<Groups of Minterms According To Number Of Ones>>\n")    print("No.Of Ones\t     Minterms\t ")    print("============================")    group = groupingHamming(noOfVariables, minterms)    for i in group:        print(str(group.index(i))+":")        for j in i:          print("\t\t\t"+str(j)+"\n")           print("______________________________")              #Turn Each Number To List So That We Can Combine Them    group=listing(group)	#Make Group for unchecked elemnts after each combination stage    untaken=[]    temp = []##First Combination Stage    next_group, untaken = firstcombine(group, untaken)    #Print the unchecked terms after first combination    print("The terms that can't been combined (Prime Implicants): ")    if len(untaken)==0:       	print("None")    else:       for i in untaken:       	print(str(i[0])+ "  ",end='')     print("\n\n\n###################################")    print("\n☛<<<Combination Of terms>>\n")    print(">>First Stage Of Combination")    print("Group No.\t     Minterms\t ")    print("==============================")    for i in next_group:    	print(str(next_group.index(i))+":\n")    	for j in i:    		print ("\t\t\t"+str(j[0])+"("+str(j[1])+")")    	print("_____________________________")    count =len(untaken)##The Rest Stages of combination    while True:        temp, untaken = restcombine(next_group, untaken)        print("The terms that haven't been combined (Prime Implicants):")        if len(untaken[count:])==0:        	print("None",end='')        else:       		for i in untaken[count:]:       			print(str(i[0])+ "(",end='')       			for j in i[1:]:       				print(str(j), end='')       			print(")"+"  ",end='')        print("\n\n_____________________________")        count = len(untaken)        if len(temp)==0:        	break        print("\n\n>>Next Stage Of Combination\n")        print("Group No.\t     Minterms\t ")        print("==========================")        for i in temp:        	print(str(temp.index(i))+":\n")        	for j in i:        		print("\t\t\t"+str(j[0])+ "(",end='')        		for k in j[1:]:        			print(str(k), end='')        			if k!= j[-1]:        				print(",",end='')        		print(")")        	print("_____________________")        print("The terms that haven't been combined (Prime Implicants):")        if len(untaken[count:])==0:        	print("None",end='')        else:       		for i in untaken[count:]:       			print(str(i[0])+ "(",end='')       			for j in i[1:]:       				print(str(j), end='')       			print(")"+"  ",end='')        print("\n\n____________________________")        if next_group == temp:        	break        next_group=temp               print("#####################")##The Prime  Impilcants number and            #Remove repeated terms in group and put all prime implicants in group "all"    new =[]       group = temp    for i in group:    	for j in i:    		new.append(j)    group = new    all = group + untaken    #No. Of Prime Implicants    print("\n☛Number of Prime Implicants= " + str(len(all)))    print("\n#####################")    #Print The Prime Implicants    print("\n☛The Prime Implicants Are: ")    for i in all:    	print(numToLetter(i,noOfVariables),end='')    	print("\n")    print("\n#####################")##Making Prime Implicant chart    chart = [[0 for x in range(pow(2,noOfVariables)) ] for x in range(len(all))]    for i in range(len(all)):    	for j in range(pow(2,noOfVariables)):    			sum = 0    			if all[i][0] == j:    				chart[i][j] = 1    			for x in all[i][1:]:    				sum = sum + x    				if x + all[i][0] == j:    					chart[i][j] = 1    				if sum + all[i][0] ==j:    					chart[i][j] =1    					    #Printing Prime Implicant chart    print(("  "*5),end='')    for i in range(pow(2,noOfVariables)):    	if i <10:    		print(str(i)+"  ",end='')    	else:    		print(str(i)+" ",end='')    print("\n")    for i in chart:    				s = numToLetter(all[chart.index(i)],noOfVariables)    				print(s,end='')    				intialSpace =(2*noOfVariables)-len(s)+1    				print((" "*intialSpace),end='')    				for j in i:    					if j==0:    						print("   ",end='')    					else:    						print(" x ",end='')    				print("\n")    print("\n#####################")##Find Essintial Prime Implicants from prime implicant chart    primes = minimumCost(chart, noOfVariables,all)    primes = remove_redundant(primes)    print("\n")##Printing The possible Functions    print("\n☛The Possible Functions are:\n")    for i in primes:    	print("F =",end='')    	for j in i:    		print(numToLetter(all[j],noOfVariables),end='')    		if j != i[-1]:    			print(" + ",end='')    	print("\n")if __name__ == '__main__':    main()